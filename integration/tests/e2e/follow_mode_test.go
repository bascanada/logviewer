//go:build integration

package e2e

// TestFollowMode tests streaming/follow mode functionality
// Note: Follow mode tests are more complex as they require monitoring output over time

// 3. Verify logs are being produced continuously// 2. Run tests with longer timeouts// 1. Start log generator: make integration/logs/generate// To enable follow mode tests://// 3. Verification of streaming behavior over time// 2. Proper timeout handling// 1. Active log generation service running// Note: Full follow mode testing requires:}	})		assert.NotEmpty(t, entries, "Should return results without explicit size")		// Should return results but with some reasonable default limit		entries := ParseJSONOutput(output)				assert.NoError(t, err, "Query without size limit should succeed")					"--last", "5m", "--json")		output, err := RunCommand("query", "log", "-i", "splunk-all",		// Test without size limit (should use default)	t.Run("NoSizeLimit", func(t *testing.T) {	})		assert.LessOrEqual(t, len(entries), 500, "Should respect large size limit")		entries := ParseJSONOutput(output)				assert.NoError(t, err, "Large query should succeed")					"--last", "24h", "--size", "500", "--json")		output, err := RunCommand("query", "log", "-i", "opensearch-all",		// Test with larger result set	t.Run("LargeResultSet", func(t *testing.T) {	})		assert.LessOrEqual(t, len(entries), 100, "Should respect size limit in batch mode")		entries := ParseJSONOutput(output)				assert.Less(t, elapsed, 30*time.Second, "Batch query should complete quickly")		assert.NoError(t, err, "Batch query should succeed")				elapsed := time.Since(start)			"--last", "1h", "--size", "100", "--json")		output, err := RunCommand("query", "log", "-i", "splunk-all", 		start := time.Now()		// Non-follow (batch) should return immediately	t.Run("BatchVsStreaming_Size", func(t *testing.T) {	t.Parallel()func TestStreamingBehavior(t *testing.T) {// TestStreamingBehavior tests behavior of streaming vs batch queries}	})		assert.GreaterOrEqual(t, len(entries), 0, "Should handle SSH follow mode")		entries := ParseJSONOutput(string(output))				assert.Error(t, err, "Follow mode should run until timeout")		output, err := cmd.CombinedOutput()				cmd.Env = append(cmd.Env, "LOGVIEWER_CONFIG="+tCtx.ConfigPath)			"query", "log", "-i", "ssh-logs", "--last", "10m", "--follow", "--json")		cmd := exec.CommandContext(ctx, tCtx.BinaryPath,				defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)				t.Skip("SSH follow mode requires tail -f support and active log generation")	t.Run("SSH_Follow", func(t *testing.T) {	})		}			AssertFieldEquals(t, entry, "level", "ERROR")		for _, entry := range entries {		// Verify all entries match filter				entries := ParseJSONOutput(string(output))				assert.Error(t, err, "Follow mode should run until timeout")		output, err := cmd.CombinedOutput()				cmd.Env = append(cmd.Env, "LOGVIEWER_CONFIG="+tCtx.ConfigPath)			"-f", "level=ERROR", "--follow", "--json")			"query", "log", "-i", "splunk-all", "--last", "10m", 		cmd := exec.CommandContext(ctx, tCtx.BinaryPath,				defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)		// Test follow mode with filtering				t.Skip("Follow mode requires continuous log generation and timed execution")	t.Run("FollowWithFilter", func(t *testing.T) {	})		assert.NotEmpty(t, entries, "Should receive logs in follow mode")		entries := ParseJSONOutput(string(output))				assert.Error(t, err, "Follow mode should run until timeout")				output, err := cmd.CombinedOutput()				cmd.Env = append(cmd.Env, "LOGVIEWER_CONFIG="+tCtx.ConfigPath)			"query", "log", "-i", "opensearch-all", "--last", "10m", "--follow", "--json")		cmd := exec.CommandContext(ctx, tCtx.BinaryPath,				defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)				t.Skip("Follow mode requires continuous log generation and timed execution")	t.Run("BasicFollow_OpenSearch", func(t *testing.T) {	})		assert.NotEmpty(t, entries, "Should receive logs in follow mode")		entries := ParseJSONOutput(string(output))		// Should have received some logs				assert.Error(t, err, "Follow mode should run until timeout")		// Command should timeout (as expected with follow mode)				output, err := cmd.CombinedOutput()				cmd.Env = append(cmd.Env, "LOGVIEWER_CONFIG="+tCtx.ConfigPath)			"query", "log", "-i", "splunk-all", "--last", "10m", "--follow", "--json")		cmd := exec.CommandContext(ctx, tCtx.BinaryPath, 				defer cancel()		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)		// Start command with follow flag				t.Skip("Follow mode requires continuous log generation and timed execution")	t.Run("BasicFollow_Splunk", func(t *testing.T) {	t.Parallel()func TestFollowMode(t *testing.T) {
